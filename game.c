#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app.

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  Obstacle o1 = {WIDTH + 1, randint(0, HEIGHT - 30), 0};
  Obstacle o2 = {WIDTH + 131,randint(0, HEIGHT - 30), 0 };
  Obstacle o3 = {WIDTH + 261,randint(0, HEIGHT - 30), 0 };
  
  u16 obstacleColor = GREEN;
  GBAState state = START;
  int score = 0;

  drawFullScreenImageDMA(bg_game);
  BirdPos bird_pos = {HEIGHT/2 - BIRD_HEIGHT/2, WIDTH/2 - BIRD_WIDTH/2};
  drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
  char gameName[] = "Flappy Angry Bird";
  drawCenteredString(0, 0, WIDTH, HEIGHT/2, gameName, BLACK);
  char startMessage[] = "press ENTER to start game";
  drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/4*3, startMessage, BLACK);
  int menuMovingLeft = 0;
  int menuMovingUp = 1;

  while (1) {
    waitForVBlank();
    currentButtons = BUTTONS;  // Load the current state of the buttons
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      case START:
        menuMove(&menuMovingLeft, &menuMovingUp, &bird_pos);

        if (KEY_JUST_RELEASED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);

          bird_pos.row = HEIGHT/2 - BIRD_HEIGHT/2;
          bird_pos.col = WIDTH/2 - BIRD_WIDTH/2;
          drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
          
          displayReadyMessage(0);
          state = PLAY;
        }

        break;
      case PLAY:
        if (KEY_JUST_RELEASED(BUTTON_SELECT, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);
          bird_pos.row = HEIGHT/2 - BIRD_HEIGHT/2;
          bird_pos.col = WIDTH/2 - BIRD_WIDTH/2;
          drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
          drawCenteredString(0, 0, WIDTH, HEIGHT/2, gameName, BLACK);
          drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/4*3, startMessage, BLACK);
          state = START;

          //resetting game data
          score = 0;
          o1.col = WIDTH + 1;
          o1.row = randint(0, HEIGHT - 30);
          o1.passed = 0;
          o2.col = WIDTH + 131;
          o2.row = randint(0, HEIGHT - 30);
          o2.passed = 0;
          o3.col = WIDTH + 261;
          o3.row = randint(0, HEIGHT - 30);
          o3.passed = 0;
          break;
        }       

        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);
          char paused[] = "Paused";
          drawCenteredString(0, 0, WIDTH, HEIGHT, paused, BLACK);
          drawContinue();
          state = PAUSE;
          break;
        }

        int previousScore = score;
        int changed = 0;
        moveObstacle(&o1, obstacleColor, &score, &changed);
        moveObstacle(&o2, obstacleColor, &score, &changed);
        moveObstacle(&o3, obstacleColor, &score, &changed);
        if (changed) {
          clearScoreArea(&o1, &o2, &o3, &obstacleColor, &bird_pos);
        }

        controlMove(&bird_pos);

        //Check if bird hit the obstacle
        if (bird_pos.row < o1.row || bird_pos.row > o1.row + 30 - BIRD_HEIGHT) {
          if (bird_pos.col > o1.col - BIRD_WIDTH && bird_pos.col < o1.col + 30) {
            if (score < 10) {
              birdBlink(&bird_pos, &obstacleColor, &o1, &o2, &o3, score);

              drawFromTop(loss);
              for (int count = 0; count < 500; count++) {
                waitForVBlank();
              }

              drawFullScreenImageDMA(game_over);
              char over[] = "GAME OVER";
              drawCenteredString(0, 0, WIDTH, HEIGHT, over, BLACK);
              drawScore(score);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = LOSE;
            } else {
              drawFullScreenImageDMA(bg_game);
              char endScore[20];
              sprintf(endScore, "Your score: %d", score);
              drawCenteredString(0, 0, WIDTH, HEIGHT, endScore, BLACK);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = END;
            }
            break;
          }
        }
        if (bird_pos.row < o2.row || bird_pos.row > o2.row + 30 - BIRD_HEIGHT) {
          if (bird_pos.col > o2.col - BIRD_WIDTH && bird_pos.col < o2.col + 30) {
            if (score < 10) {
              birdBlink(&bird_pos, &obstacleColor, &o1, &o2, &o3, score);

              drawFromTop(loss);
              for (int count = 0; count < 500; count++) {
                waitForVBlank();
              }

              drawFullScreenImageDMA(game_over);
              char over[] = "GAME OVER";
              drawCenteredString(0, 0, WIDTH, HEIGHT, over, BLACK);
              drawScore(score);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = LOSE;
            } else {
              drawFullScreenImageDMA(bg_game);
              char endScore[20];
              sprintf(endScore, "Your score: %d", score);
              drawCenteredString(0, 0, WIDTH, HEIGHT, endScore, BLACK);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = END;
            }
            break;
          }
        }
        if (bird_pos.row < o3.row || bird_pos.row > o3.row + 30 - BIRD_HEIGHT) {
          if (bird_pos.col > o3.col - BIRD_WIDTH && bird_pos.col < o3.col + 30) {
            if (score < 10) {
              birdBlink(&bird_pos, &obstacleColor, &o1, &o2, &o3, score);

              drawFromTop(loss);
              for (int count = 0; count < 500; count++) {
                waitForVBlank();
              }

              state = LOSE;
              drawFullScreenImageDMA(game_over);
              char over[] = "GAME OVER";
              drawCenteredString(0, 0, WIDTH, HEIGHT, over, BLACK);
              drawScore(score);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = LOSE;
            } else {
              drawFullScreenImageDMA(bg_game);
              char endScore[20];
              sprintf(endScore, "Your score: %d", score);
              drawCenteredString(0, 0, WIDTH, HEIGHT, endScore, BLACK);
              char proceed[] = "press ENTER to proceed";
              drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/2, proceed, BLACK);
              state = END;
            }
            break;
          }
        }

        //Check score
        if (bird_pos.col >= o1.col + 30 && !o1.passed) {
          score++;
          o1.passed = 1;
          clearScoreArea(&o1, &o2, &o3, &obstacleColor, &bird_pos);
        }
        if (bird_pos.col >= o2.col + 30 && !o2.passed) {
          score++;
          o2.passed = 1;
          clearScoreArea(&o1, &o2, &o3, &obstacleColor, &bird_pos);
        }
        if (bird_pos.col >= o3.col + 30 && !o3.passed) {
          score++;
          o3.passed = 1;
          clearScoreArea(&o1, &o2, &o3, &obstacleColor, &bird_pos);
        } 
        drawScore(score);
        drawPause();

        if (previousScore == 9 && score == 10) {
          for (int count = 0; count < 500; count++) {
            waitForVBlank();
          }
          drawFullScreenImageDMA(bg_game);
          drawScore(score);
          char win[] = "YOU WIN!!!";
          drawCenteredString(0, 0, WIDTH, HEIGHT, win, BLACK);
          for (int count = 0; count < 1000; count++) {
            waitForVBlank();
          }

          drawFullScreenImageDMA(bg_game);
          char message[] = "Continue to earn higher score?";
          drawCenteredString(0, 0, WIDTH, HEIGHT, message, BLACK);
          drawScore(score);
          char yes[] = "YES(ENTER)";
          char no[] = "NO(BACKSPACE)";
          drawCenteredString(HEIGHT/2, 0, WIDTH/2, HEIGHT/2, yes, BLACK);
          drawCenteredString(HEIGHT/2, WIDTH/2, WIDTH/2, HEIGHT/2, no, BLACK);
          state = WIN;
        }
        break;

      case PAUSE:
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {

          if (bird_pos.row >= HEIGHT / 2 - BIRD_HEIGHT / 2) {
            displayReadyContinue(0, &o1, &o2, &o3, score, &bird_pos, &obstacleColor);
          } else {
            displayReadyContinue(1, &o1, &o2, &o3, score, &bird_pos, &obstacleColor);
          }
          state = PLAY;
        }
        break;
      case WIN:
        if (KEY_JUST_RELEASED(BUTTON_SELECT, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);
          bird_pos.row = HEIGHT/2 - BIRD_HEIGHT/2;
          bird_pos.col = WIDTH/2 - BIRD_WIDTH/2;
          drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
          drawCenteredString(0, 0, WIDTH, HEIGHT/2, gameName, BLACK);
          drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/4*3, startMessage, BLACK);
          state = START;
          //resetting game data
          score = 0;
          o1.col = WIDTH + 1;
          o1.row = randint(0, HEIGHT - 30);
          o1.passed = 0;
          o2.col = WIDTH + 131;
          o2.row = randint(0, HEIGHT - 30);
          o2.passed = 0;
          o3.col = WIDTH + 261;
          o3.row = randint(0, HEIGHT - 30);
          o3.passed = 0;
          break;
        }
        if (KEY_JUST_RELEASED(BUTTON_START, currentButtons, previousButtons)) {
          if (bird_pos.row >= HEIGHT / 2 - BIRD_HEIGHT / 2) {
            displayReadyContinue(0, &o1, &o2, &o3, score, &bird_pos, &obstacleColor);
          } else {
            displayReadyContinue(1, &o1, &o2, &o3, score, &bird_pos, &obstacleColor);
          }
          state = PLAY;
        }
        break;
      case LOSE:
        if (KEY_JUST_RELEASED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);
          bird_pos.row = HEIGHT/2 - BIRD_HEIGHT/2;
          bird_pos.col = WIDTH/2 - BIRD_WIDTH/2;
          drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
          drawCenteredString(0, 0, WIDTH, HEIGHT/2, gameName, BLACK);
          drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/4*3, startMessage, BLACK);
          state = START;
          //resetting game data
          score = 0;
          o1.col = WIDTH + 1;
          o1.row = randint(0, HEIGHT - 30);
          o1.passed = 0;
          o2.col = WIDTH + 131;
          o2.row = randint(0, HEIGHT - 30);
          o2.passed = 0;
          o3.col = WIDTH + 261;
          o3.row = randint(0, HEIGHT - 30);
          o3.passed = 0;
          break;
        }
        break;
      case END:
        if (KEY_JUST_RELEASED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(bg_game);
          bird_pos.row = HEIGHT/2 - BIRD_HEIGHT/2;
          bird_pos.col = WIDTH/2 - BIRD_WIDTH/2;
          drawImageDMA(bird_pos.row, bird_pos.col, BIRD_WIDTH,BIRD_HEIGHT,bird);
          drawCenteredString(0, 0, WIDTH, HEIGHT/2, gameName, BLACK);
          drawCenteredString(HEIGHT/2, 0, WIDTH, HEIGHT/4*3, startMessage, BLACK);
          state = START;
          //resetting game data
          score = 0;
          o1.col = WIDTH + 1;
          o1.row = randint(0, HEIGHT - 30);
          o1.passed = 0;
          o2.col = WIDTH + 131;
          o2.row = randint(0, HEIGHT - 30);
          o2.passed = 0;
          o3.col = WIDTH + 261;
          o3.row = randint(0, HEIGHT - 30);
          o3.passed = 0;
          break;
        }
        break;
    }

    previousButtons = currentButtons;  // Store the current state of the buttons
  }
  return 0;
}

void moveDown(BirdPos *b) {
  //waitForVBlank();
  if (b -> row < HEIGHT - BIRD_HEIGHT) {
    //Reset image at original place
    DMA[DMA_CHANNEL_3].src = &bg_game[OFFSET(b -> row, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(b -> row, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_INCREMENT | BIRD_WIDTH;
    b -> row++;
  }
  drawImageDMA(b -> row, b -> col, BIRD_WIDTH,BIRD_HEIGHT,bird);
}

void moveUp(BirdPos *b) {
  //waitForVBlank();
  if (b -> row > 0) {
    //Reset image at original place
    DMA[DMA_CHANNEL_3].src = &bg_game[OFFSET(b -> row + BIRD_HEIGHT - 1, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(b -> row + BIRD_HEIGHT - 1, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_INCREMENT | BIRD_WIDTH;
    b -> row--;
  }
  drawImageDMA(b -> row, b -> col, BIRD_WIDTH,BIRD_HEIGHT,bird);
}

void moveLeft(BirdPos *b) {
  if (b -> col != 0) {
    for (int h = 0; h < BIRD_HEIGHT; h++) {
      setPixel(b -> row + h, b -> col + BIRD_WIDTH - 1, 
      bg_game[OFFSET(b -> row + h, b -> col + BIRD_WIDTH - 1, WIDTH)]);
    }
    b -> col--;
    drawImageDMA(b -> row, b -> col, BIRD_WIDTH,BIRD_HEIGHT,bird);
  }
}

void moveRight(BirdPos *b) {
  if (b -> col != WIDTH - BIRD_WIDTH) {
    for (int h = 0; h < BIRD_HEIGHT; h++) {
      setPixel(b -> row + h, b -> col, 
      bg_game[OFFSET(b -> row + h, b -> col, WIDTH)]);
    }
    b -> col++;
    drawImageDMA(b -> row, b -> col, BIRD_WIDTH,BIRD_HEIGHT,bird);
  }
}

void menuMove(int *menuMovingLeft, int *menuMovingUp, BirdPos *b) {
    if (*menuMovingLeft) {
    if (b -> col) {
      moveLeft(b);
    } else {
      *menuMovingLeft = 0;
      moveRight(b);
    }
  } else {
    if (b -> col != WIDTH - BIRD_WIDTH) {
      moveRight(b);
    } else {
      *menuMovingLeft = 1;
      moveLeft(b);
    }
  }
  if (*menuMovingUp) {
    if (b -> row != HEIGHT/3) {
      moveUp(b);
    } else {
      *menuMovingUp = 0;
      moveDown(b);
    }
  } else {
    if (b -> row != HEIGHT/3*2) {
      moveDown(b);
    } else {
      *menuMovingUp = 1;
      moveUp(b);
    }
  }
}

void controlMove(BirdPos* b) {
    if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
    moveUp(b);
  }

  if (KEY_DOWN(BUTTON_DOWN, BUTTONS)) {
    moveDown(b);
  }

  if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {
    moveLeft(b);
  }

  if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
    moveRight(b);
  }
}

void displayReadyMessage(int bottomHalf) {
  int r = bottomHalf * HEIGHT / 2;
  char ready[] = "Ready...";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, ready, BLACK);
  for (int count = 0; count < 500; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);

  char set[] = "Set...";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, set, BLACK);
  for (int count = 0; count < 500; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);

  char go[] = "Go!";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, go, BLACK);
  for (int count = 0; count < 750; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);
}

void displayReadyContinue(int bottomHalf, Obstacle *o1, Obstacle *o2, Obstacle *o3, int score, BirdPos* b,
 u16* color) {
  int r = bottomHalf * HEIGHT / 2;

  drawFullScreenImageDMA(bg_game);
  clearScoreArea(o1, o2, o3, color, b);
  char ready[] = "Ready...";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, ready, BLACK);

  drawScore(score);
  for (int count = 0; count < 500; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);

  clearScoreArea(o1, o2, o3, color, b);
  char set[] = "Set...";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, set, BLACK);
  drawScore(score);
  for (int count = 0; count < 500; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);

  clearScoreArea(o1, o2, o3, color, b);
  char go[] = "Go!";
  drawCenteredString(r, 0, WIDTH, HEIGHT/2, go, BLACK);
  drawScore(score);
  for (int count = 0; count < 750; count++) {
    waitForVBlank();
  }
  drawImageDMA(r, 0,WIDTH, HEIGHT/2 - BIRD_HEIGHT, &bg_game[OFFSET(r, 0, WIDTH)]);
  clearScoreArea(o1, o2, o3, color, b);
  drawScore(score);
  drawPause();
}

void moveObstacle(Obstacle* o, u16 color, int* score, int* changed) {
  o -> col--;
  if (o -> col < WIDTH && o -> col >= WIDTH - 30) {
    for (int r = 0; r < o -> row; r++) {
      setPixel(r, o -> col, color);
    }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      setPixel(r, o -> col, color);
    }    
  } else if (o -> col < WIDTH - 30 && o -> col >= 0) {
    for (int r = 0; r < o -> row; r++) {
      setPixel(r, o -> col, color);
      setPixel(r, o -> col + 30, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      setPixel(r, o -> col, color);
      setPixel(r, o -> col + 30, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }   
  } else if (o -> col < 0 && o -> col > -30) {
    for (int r = 0; r < o -> row; r++) {
      setPixel(r, o -> col + 30, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      setPixel(r, o -> col + 30, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }   
  } else if (o -> col <= -30) {
    if (!o -> passed) {
      *score = *score + 1;
      *changed = 1;
    }
    for (int r = 0; r < o -> row; r++) {
      setPixel(r, 0, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      setPixel(r, 0, bg_game[OFFSET(r, o -> col + 30, WIDTH)]);
    }   
    o -> col = 360;
    o -> row = randint(0, HEIGHT - 29);
    o -> passed = 0;
  }
}

void drawObstacle(Obstacle* o, u16* color) {
  if (o -> col < WIDTH && o -> col >= WIDTH - 30) {
    for (int r = 0; r < o -> row; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, o -> col, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | (WIDTH - o -> col);
      }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, o -> col, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | (WIDTH - o -> col);
    } 
  } else if (o -> col < WIDTH - 30 && o -> col >= 0) {
    for (int r = 0; r < o -> row; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, o -> col, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | 30;
      }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, o -> col, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | 30;
    } 
  } else if (o -> col < 0 && o -> col > -30) {
    for (int r = 0; r < o -> row; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, 0, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | (30 + o -> col);
      }
    for (int r = o -> row + 30; r <= WIDTH; r++) {
      DMA[DMA_CHANNEL_3].src = color;
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, 0, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_FIXED | (30 + o -> col);
    } 
  }
}

void drawScore(int score) {
  char displayScore[12];
  sprintf(displayScore, "Score: %d", score);
  drawCenteredString(5, 5, 50, 20, displayScore, BLACK);
}

void clearScoreArea(Obstacle* o1, Obstacle* o2, Obstacle* o3, u16* color, BirdPos* b) {
  for (int r = 5; r < 25; r++) {
      DMA[DMA_CHANNEL_3].src = &bg_game[OFFSET(r, 5, WIDTH)];
      DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, 5, WIDTH)];
      DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_INCREMENT | 80;
  }
  drawObstacle(o1, color);
  drawObstacle(o2, color);
  drawObstacle(o3, color);
  drawImageDMA(b ->row, b -> col, BIRD_WIDTH, BIRD_HEIGHT, bird);
}

void clearBird(BirdPos* b) {
  for (int r = 0; r < BIRD_HEIGHT; r++) {
    DMA[DMA_CHANNEL_3].src = &bg_game[OFFSET(b ->row + r, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(b -> row + r, b -> col, WIDTH)];
    DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_INCREMENT | BIRD_WIDTH;
  }
}

void drawPause(void) {
  char pause[] = "press Z to pause";
  drawCenteredString(5, WIDTH - 80, 50, 20, pause, BLACK);
}

void drawContinue(void) {
  char pause[] = "press Z to continue";
  drawCenteredString(5, WIDTH - 90, 50, 20, pause, BLACK);
}

void birdBlink(BirdPos* b, u16* color, Obstacle* o1, Obstacle* o2, Obstacle* o3, int score) {
  for (int count = 0; count < 100; count++) {
    waitForVBlank();
  }

  for (int times = 0; times < 3; times++) {
    clearBird(b);
    for (int r = 5; r < 25; r++) {
        DMA[DMA_CHANNEL_3].src = &bg_game[OFFSET(r, 5, WIDTH)];
        DMA[DMA_CHANNEL_3].dst = &videoBuffer[OFFSET(r, 5, WIDTH)];
        DMA[DMA_CHANNEL_3].cnt = DMA_ON | DMA_SOURCE_INCREMENT | 80;
    }
    drawObstacle(o1, color);
    drawObstacle(o2, color);
    drawObstacle(o3, color);
    drawScore(score);
    drawPause();

    for (int count = 0; count < 250; count++) {
      waitForVBlank();
    }
  
    drawImageDMA(b ->row, b -> col, BIRD_WIDTH, BIRD_HEIGHT, bird);
    
    for (int count = 0; count < 250; count++) {
      waitForVBlank();
    }
  }
}